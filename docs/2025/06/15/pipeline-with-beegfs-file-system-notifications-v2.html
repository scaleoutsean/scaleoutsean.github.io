<!doctype html>
<html lang="en">
  <head>
        <meta charset="UTF-8">
    <meta http-equiv="content-language" content="en">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="googlebot" content="noarchive">
    <meta name="googlebot" content="max-snippet:60">
    <meta name="googlebot" content="max-image-preview:small">
    <meta name="bingbot" content="noarchive">
    <meta name="bingbot" content="max-snippet:60">
    <meta name="bingbot" content="max-image-preview:small">
    <meta name="robots" content="noarchive">
    <meta name="robots" content="max-snippet:60">
    <meta name="google-site-verification" content="F6q7vIwQ2G0j8tk-KL9rAXOMLXMDMMUkEz4fRs1Nnnc" />
    <title>
        
            Improved pipelines with BeeGFS FS Event Notifications in v8 | Acting Technologist
      
    </title>
    <meta name="description" content="
     More on improvements in BeeGFS file-system event notifications
     ">

    <!-- LINK TO ATOM FEED FOR SEO -->
    <link rel="alternate" type="application/atom+xml" href="https://scaleoutsean.github.io/feed.xml" />

    <!-- FAVICON -->
    <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/syntax.css">

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">

    <link href="/_pagefind/pagefind-ui.css" rel="stylesheet">
    <script src="/_pagefind/pagefind-ui.js" type="text/javascript"></script>
    <div id="search"></div>
    <script src="https://cdn.counter.dev/script.js" data-id="83dc700a-b821-4e57-9425-02b8336a9456" data-utcoffset="0"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            new PagefindUI({ element: "#search" });
        });
    </script>

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Improved pipelines with BeeGFS FS Event Notifications in v8 | Acting Technologist</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Improved pipelines with BeeGFS FS Event Notifications in v8" />
<meta name="author" content="scaleoutSean" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="More on improvements in BeeGFS file-system event notifications" />
<meta property="og:description" content="More on improvements in BeeGFS file-system event notifications" />
<link rel="canonical" href="https://scaleoutsean.github.io/2025/06/15/pipeline-with-beegfs-file-system-notifications-v2.html" />
<meta property="og:url" content="https://scaleoutsean.github.io/2025/06/15/pipeline-with-beegfs-file-system-notifications-v2.html" />
<meta property="og:site_name" content="Acting Technologist" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-15T00:00:00+08:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"scaleoutSean"},"description":"More on improvements in BeeGFS file-system event notifications","@type":"BlogPosting","headline":"Improved pipelines with BeeGFS FS Event Notifications in v8","dateModified":"2025-06-15T00:00:00+08:00","datePublished":"2025-06-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://scaleoutsean.github.io/2025/06/15/pipeline-with-beegfs-file-system-notifications-v2.html"},"url":"https://scaleoutsean.github.io/2025/06/15/pipeline-with-beegfs-file-system-notifications-v2.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

<body>

  <div class="container">
    <header id="header">
	<div id = site_title>
		<a href="https://scaleoutsean.github.io/">
			<h2 style="font-size:1.8em;">Acting Technologist</h2>
		</a>
		
		<h3>
			civilizations are created by individuals
		</h3>
		
	</div>

	<div id="subheader">
		
		<nav class="pages">
<a href="/about.html">About</a>

<a href="/archive.html">Archive</a>

<a href="/categories/">Categories</a>

<a href="/projects.html">Projects</a>
</nav>
		
		
		<nav class="social">
			
  
    <a href="https://www.github.com/scaleoutsean" target="_blank" id="github"><i class="fab fa-github" aria-hidden="true"></i></a>
  
   

  
    <a href="https://twitter.com/scaleoutsean" target="_blank" id="twitter"><i class="fab fa-twitter" aria-hidden="true"></i></a>
  
   

  
  
    <a href="/feed.xml" target="_blank" id="rss"><i class="fas fa-rss" aria-hidden="true"></i></a>
   

		</nav>
		
	</div>
</header>


    <div class="post-container">
      <article id = "post">
        <h1 id = "post-title">Improved pipelines with BeeGFS FS Event Notifications in v8</h1>

  
  <div class = "post-info">
    <span>
        <i class="far fa-calendar" aria-hidden="true"></i> <span>15 Jun 2025</span> - <i class="far fa-clock"></i> 


  
  
    9 minute read
  

    </span>
  </div>
  
        <ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#whats-new-in-beegfs-file-system-events-in-beegfs-v8">What’s new in BeeGFS file-system events in BeeGFS v8</a>
    <ul>
      <li><a href="#dude-wheres-my-grpc-server">Dude, where’s my gRPC server?</a></li>
      <li><a href="#can-beegfs-watch-server-erhm-client-drop-messages">Can BeeGFS watch server, erhm, client, drop messages</a></li>
      <li><a href="#file-system-notification-messages">File-system notification messages</a></li>
    </ul>
  </li>
  <li><a href="#use-case-data-pipeline-for-storagegrid">Use case: data pipeline for StorageGRID</a>
    <ul>
      <li><a href="#advantages">Advantages</a></li>
      <li><a href="#limitations">Limitations</a></li>
    </ul>
  </li>
  <li><a href="#performance-and-security">Performance (and security)</a></li>
  <li><a href="#conclusion-and-ideas-for-future-work">Conclusion and ideas for future work</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>I actually blogged about this right here: <a href="/2025/05/17/beegfs-v8-netapp-e-series-indexing-tiering-workflows.html#file-system-events">Filesystem events</a>, so I’ll skip 90% of what I wrote in that post and just build on that here.</p>

<p>Secondly, some years ago I wrote about implementing <a href="/2024/01/29/antivirus-scanning-for-on-premises-s3.html">anti-virus scanning for StorageGRID</a>. I’ll revisit that as a use case - maybe a ‘stretch use case’, but fun - for using BeeGFS file-system event notifications.</p>

<h2 id="whats-new-in-beegfs-file-system-events-in-beegfs-v8">What’s new in BeeGFS file-system events in BeeGFS v8</h2>

<p>If you’re interested in some background, see the related section of that recent post above.</p>

<p>To keep it simple, here’s how I’d explain it (without reading the FS events code from v7, which puts me at a disadvantage):</p>

<ul>
  <li>Old notifications weren’t easily accessible (see the article above)</li>
  <li>New (v8) notifications use gRPC client to send them, and can easily and reliably dispatch thousands of notifications per second to multiple remote servers</li>
  <li>Implementing the server is “an exercise for the reader”, as they say</li>
</ul>

<h3 id="dude-wheres-my-grpc-server">Dude, where’s my gRPC server?</h3>

<p>You have to write it. The reason(s) is/are explained in <code class="language-plaintext highlighter-rouge">beegfs-go</code>, along with other useful information. Based on the <a href="https://github.com/ThinkParQ/beegfs-go/commit/78a7f84a88d4473b702be31cc4a4d76b7c1b6eff">current</a> README file, it appears ThinkParQ didn’t want to get too prescriptive too early.</p>

<p>For now users are expected to roll their own - and only gRPC notifications are sent - but as use cases and requirements get surfaced to them, they will likely improve it.</p>

<h3 id="can-beegfs-watch-server-erhm-client-drop-messages">Can BeeGFS watch server, erhm, client, drop messages</h3>

<p>Currently - also from that read-me - it stores (and buffers) messages in memory, so it won’t lose sent-and-acknowledged messages, but it could lose not-yet-sent ones. As the read-me explains, the reason is they thought the best way is to build this into metadata service rather than to watch service, which is a to-do item.</p>

<h3 id="file-system-notification-messages">File-system notification messages</h3>

<p>The read-me was confusing to me, as it took me a while to realize what’s what. Frankly speaking, I don’t like that Watch service (so, a server) is a client (a gRPC client), while gRPC server is a “subscriber” (which sounds very client-ish to me). This wasted me some time when setting this up. (Not that I’m a gRPC expert, but it <em>added</em> to my usual stumbling.)</p>

<p>Anyhow, the linked repository has gRPC protocol definition files, so not unexpectly messages look exactly like the “proto” files intend them to look.</p>

<pre><code class="language-raw">seq_id: 1341
meta_id: 1
v2 {
  type: OPEN_READ
  num_links: 1
  path: "/main.log"
  entry_id: "0-682A0F1C-1"
  parent_entry_id: "root"
  msg_user_id: 1000
  timestamp: 1749980308698647132
}
</code></pre>

<p>Here I simply ran <code class="language-plaintext highlighter-rouge">cat /mnt/beegfs/main.log</code> and I got the above.</p>

<p>On the server (“subscriber”) you have to ack these to make them go away i.e. to have Watch server (that is, gRPC client) know the message was well received.</p>

<p>Then, with it, you can do whatever you want. Prefix your mount point (in my case, <code class="language-plaintext highlighter-rouge">/mnt/beegfs/</code>) to those names if you need full path to file.</p>

<p>I ranted about that in the BeeGFS-related post at the top, and also the subsequent one <a href="/2025/05/23/beegfs-data-pipeline.html">here</a> (related to the annoying “reference stacks” and “pipelines” that every vendor likes to boast about as if no enterprise user can run <code class="language-plaintext highlighter-rouge">'docker compose'</code> without having a “vendor-certified” copy-paste example.).</p>

<h2 id="use-case-data-pipeline-for-storagegrid">Use case: data pipeline for StorageGRID</h2>

<p>A pipeline of the special kind - AV and anti-malware scanning - that is.</p>

<p>This was an example from the StorageGRID virus and malware scanning post linked at the top.</p>

<p><img src="/assets/images/s3-av-scan-example.png" alt="" /></p>

<p>There’s nothing wrong with it, it’s as good or as bad as any other. But, since I already ranted about data pipelines and “reference architectures” <strong>and</strong> I’ve always wanted to revisit S3 AV scanning (if you skim through that older post, I did a “PoC” but it was a simple Python script), I thought to use that example in this post.</p>

<p>Of course, it should also not be a fake example - it should be superior in some aspects, including the reason that BeeGFS may be slightly more complicated to run than single-host filesystems (although I found <a href="/2025/05/17/beegfs-v8-netapp-e-series-indexing-tiering-workflows.html#beegfs-copy-tool">BeeGFS on-demand file-systems</a> very easy to setup and tear down). Here’s an example:</p>

<p><img src="/assets/images/storagegrid-s3-scanner-beegfs.png" alt="S3 AV and malware scanning on BeeGFS" /></p>

<p>S3 service sends notifications or uses Webhooks to let us know of changes. That goes to Kafka, although I’d use something less nightmarish but compatible, as StorageGRID supports Kafka and Elasticsearch endpoints.</p>

<p>Then we have some consumer to poll these topics (probably named after StorageGRID buckets that send those notifications).</p>

<p>The “new” element - compared to the earlier approach - is that because we have a <em>very fast</em> cluster file-system and S3 happens to contain large objects, we can achieve excellent performance and scalability by downloading objects to BeeGFS (can be of BeeOND).</p>

<p>To do that, in Step 3 we dispatch S3 GET (download) jobs to all or a group of “download containers” which download objects to (say) /mnt/beegfs/av/BUCKET_NAME/.</p>

<p>BeeGFS file-system notifications are useful here because we can learn of new objects from Watch service, in Step 4.</p>

<p>Once we receive these notifications, we know downloaded files are visible to all containers (in the “AV scanning” group, if we run a dedicated job queue for that) so we can fire AV scan jobs immediately.</p>

<p>Scan results are sent to another Kafka topic (e.g. BUCKETNAME-scan-results) or elsewhere (Loki, etc.).</p>

<p>We already mentioned that the main disadvantage is now you have a small cluster to run, which isn’t hard with BeeOND. Let’s take a look at the main advantages (as I see them).</p>

<h3 id="advantages">Advantages</h3>

<p>It’s easier to scale AV scanning because pods on all BeeGFS nodes can see any object regardless of where it was downloaded (if we wanted to do that).</p>

<p>Normally we’d achieve this by using a file share, but this should run much faster even for GB-sized objects. Or maybe you’d do a download and scan on the same client, but we may need to wait a few seconds longer for an object to download and it would be harder to schedule jobs: scheduling just 2 per container could turn out to be wrong because both files could be very large.</p>

<p>Notice how here, thanks to file-system event notifications, we don’t have to wait for a “download pod” to notify us. The moment we see <code class="language-plaintext highlighter-rouge">LAST_WRITER_CLOSED</code> (event) in BeeGFS file-system path of interest, we can scan from any available “scanning pod”. Also, based on <code class="language-plaintext highlighter-rouge">PATH</code> value, which includes <code class="language-plaintext highlighter-rouge">BUCKET_NAME</code>, we can dispatch events to the appropriate “scanner group” if we use ACLs to segregate scanning groups by bucket name.</p>

<p>I also think that having separate “download” and “scanning” pods is better for performance because AV scanners aren’t burdened by IO and memory utilization spikes from S3 GET jobs.</p>

<h3 id="limitations">Limitations</h3>

<p>It’s more of a choice than a limitation: we don’t do anything with infected files. We had the same “limitation” without BeeGFS.</p>

<p>As I mentioned in the first antivirus scanning post, I can’t say I like the idea of being able to write to buckets and overwrite (and possibly delete) objects that are already there. Furthermore, versioning or even Object Lock may be enabled.</p>

<p>Those who seek to scan for viruses and malware <em>before</em> files get uploaded to S3 can do that in a Web front-end (which could also use BeeGFS) or client application.</p>

<p>I think it’s appropriate enough, and also much easier to do, to just scan and notify.</p>

<h2 id="performance-and-security">Performance (and security)</h2>

<p>Another interesting detail may be performance. gRPC ought to be faster than other approaches, so this approach should scale better than some others.</p>

<p>I took this screenshot from the gRPC project, and it shows that even Python lets us process 1,000 messages per second.</p>

<p><img src="/assets/images/grpc_python.png" alt="gRPC server in Python" /></p>

<p>I think this is Python-to-Python, whereas BeeGFS isn’t Python, so it may be faster.</p>

<p>You don’t <em>have to</em> implement the server in Python, but we can.</p>

<p>If queue-to-Kubernetes and gRPC-to-Kubernetes are private network and/or file names aren’t secret, TLS can be dropped, helping some more. We may be able to dispatch a few hundred messages per second, which is enough for “average” mid-size StorageGRID cluster.</p>

<p>For users who desire to use TLS simply because BeeGFS nodes might download “important objects” (although that’s not really related to TLS; downloads from StorageGRID would use TLS - no need to compromise there): you can take advantage of dedicated smaller BeeOND clusters (e.g. 3 VMs with 6 GB each for one particular bucket). For less militant segregation, BeeGFS has ACLs.</p>

<p>If you want to run AV scanning as batch jobs, BeeOND clusters could be created at start, and wiped after scanning is done, one by one bucket. (You can see in the BeeGFS post at the top, it takes 1 minute to get a BeeOND filesystem going).</p>

<p>Lastly, one interesting thing is that with ClamAV using containers is an interesting way to at least partially segregate scanners from host OS and it may be better for performance as well. I <em>haven’t tested that on BeeGFS</em>, but sending files from scanners to ClamAV server goes over TCP network, whereas - when every file is visible to all containers on all BeeGFS nodes - here I can use UNIX sockets and completely avoid TCP. No need for TCP and (even more) HTTPS!</p>

<h2 id="conclusion-and-ideas-for-future-work">Conclusion and ideas for future work</h2>

<p>New BeeGFS file-system notifications in version 8 are greatly improved compared to previous implementation in version 7.</p>

<p>We get more performance, more reliabile delivery, and an easier data format (gRPC events vs. DIY parsing) to work with.</p>

<p>Combined with BeeOND, it opens possibilities for secure, high-performance processing steps that require a POSIX filesystem. Antivirus scanning is one such case, but there are others.</p>

<p>When I find time I’d like to evaluate performance on low-end hardware (i.e. my home lab) to get a worst-case performance baseline for BeeGFS gRPC notifications. I’d also look at the details of Step 5 (gRPC -&gt; Kubernetes scan jobs) - Hashicorp Nomad is <a href="/2022/04/24/nomad-batch-job-scale-out-parallel-filesystem-beegfs-e-netapp-series.html">absolutely great for that</a>, but I don’t have a favorite for Kubernetes yet.</p>


      </article>
    </div>
    
      <div class="categories">
    <span><p>Categories:</p>
    
    
      <a href="
      /categories/#storage">storage</a>
      &nbsp; 
    
      <a href="
      /categories/#ai">ai</a>
      &nbsp; 
    
      <a href="
      /categories/#analytics">analytics</a>
       
    
  </span>
</div>
    

  
    <div>
      <h3>Related Posts</h3>
      <ul>
      
        <li><a href="/2024/04/23/econfig-update.html">EConfig v2</a></li>
      
        <li><a href="/2023/12/02/containerized-beegfs-with-netapp-eseries.html">Containerized BeeGFS with NetApp E-Series</a></li>
      
        <li><a href="/2022/10/20/beegfs-hsm-irods-robinhood.html">iRODS or Robinhood HSM with BeeGFS</a></li>
      
        <li><a href="/2022/09/27/beegfs-csi-nomad-kubernetes.html">Speed of volume creation with BeeGFS CSI</a></li>
      
        <li><a href="/2022/09/24/low-hanging-storage-efficiency-fruit-beegfs.html">Low-hanging BeeGFS efficiency fruit</a></li>
      
      </ul>
    </div>
  

    
  </div><footer class= "footer">
    <p>2025-06-15 19:32 </p>
    <p>Copyright © 2025 scaleoutSean. Content is released under the CC BY license. Design: Alessio Franceschi</p>
</footer>

</body>
</html>
